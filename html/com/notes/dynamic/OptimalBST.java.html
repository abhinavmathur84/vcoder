<html>
<head>
<title>OptimalBST.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { }
.s2 { color: rgb(128,128,128); font-style: italic; }
.s3 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
OptimalBST.java</FONT>
</center></TD></TR></TABLE>
<pre>

<a name="l1"><span class="ln">1    </span></a><span class="s0">package </span><span class="s1">com.notes.dynamic; 
<a name="l2"><span class="ln">2    </span></a> 
<a name="l3"><span class="ln">3    </span></a></span><span class="s2">/** 
<a name="l4"><span class="ln">4    </span></a> * Given a sorted array keys[0.. n-1] of search keys and an array freq[0.. n-1] 
<a name="l5"><span class="ln">5    </span></a> * of frequency counts, where freq[i] is the number of searches to keys[i]. 
<a name="l6"><span class="ln">6    </span></a> * Construct a binary search tree of all keys such that the total cost of all 
<a name="l7"><span class="ln">7    </span></a> * the searches is as small as possible. 
<a name="l8"><span class="ln">8    </span></a> */</span><span class="s1"> 
<a name="l9"><span class="ln">9    </span></a></span><span class="s0">public class </span><span class="s1">OptimalBST { 
<a name="l10"><span class="ln">10   </span></a> 
<a name="l11"><span class="ln">11   </span></a>    </span><span class="s0">int</span><span class="s1">[] keys; 
<a name="l12"><span class="ln">12   </span></a> 
<a name="l13"><span class="ln">13   </span></a>    </span><span class="s0">int</span><span class="s1">[] freq; 
<a name="l14"><span class="ln">14   </span></a> 
<a name="l15"><span class="ln">15   </span></a>    </span><span class="s2">//C[i][j] = min cost to perform search on on the keys from keys[i]..keys[j]</span><span class="s1"> 
<a name="l16"><span class="ln">16   </span></a>    </span><span class="s0">int</span><span class="s1">[][] cost; 
<a name="l17"><span class="ln">17   </span></a> 
<a name="l18"><span class="ln">18   </span></a>    </span><span class="s2">//sols[i][j] = root of optimal subtree which contains keys[j]...keys[j]</span><span class="s1"> 
<a name="l19"><span class="ln">19   </span></a>    Node[][] sols; 
<a name="l20"><span class="ln">20   </span></a> 
<a name="l21"><span class="ln">21   </span></a>    </span><span class="s2">// DS to store the solution</span><span class="s1"> 
<a name="l22"><span class="ln">22   </span></a>    </span><span class="s0">class </span><span class="s1">Node { 
<a name="l23"><span class="ln">23   </span></a>        </span><span class="s0">int </span><span class="s1">node; 
<a name="l24"><span class="ln">24   </span></a>        Node left; 
<a name="l25"><span class="ln">25   </span></a>        Node right; 
<a name="l26"><span class="ln">26   </span></a> 
<a name="l27"><span class="ln">27   </span></a>        Node(</span><span class="s0">int </span><span class="s1">i){ 
<a name="l28"><span class="ln">28   </span></a>            node = i; 
<a name="l29"><span class="ln">29   </span></a>            left = </span><span class="s0">null</span><span class="s1">; 
<a name="l30"><span class="ln">30   </span></a>            right = </span><span class="s0">null</span><span class="s1">; 
<a name="l31"><span class="ln">31   </span></a>        } 
<a name="l32"><span class="ln">32   </span></a>    } 
<a name="l33"><span class="ln">33   </span></a> 
<a name="l34"><span class="ln">34   </span></a>    </span><span class="s2">//Approach</span><span class="s1"> 
<a name="l35"><span class="ln">35   </span></a>    </span><span class="s2">/** 
<a name="l36"><span class="ln">36   </span></a>     * C[i][j] = min cost to perform search on keys from keys[i]--key[j] and sols[j][j] will have the root 
<a name="l37"><span class="ln">37   </span></a>     *  We loop over all j-i+1 elements making each one of them as root and compute the cost 
<a name="l38"><span class="ln">38   </span></a>     *  We then chose the min of all possible BST. 
<a name="l39"><span class="ln">39   </span></a>     *  C[i][j] =  min{C[i,k-1]+sum(i,k-1)+freq[k]+C[k+1,j]+sum(k+1,j)} and 
<a name="l40"><span class="ln">40   </span></a>     *  for such a k , Node left = new Node(sols[i][k-1]) 
<a name="l41"><span class="ln">41   </span></a>     *                 Node right = new Node(sols[k+1][j]} 
<a name="l42"><span class="ln">42   </span></a>     *                 Node root = new Node(freq[k]); 
<a name="l43"><span class="ln">43   </span></a>     *                 root.left = left; 
<a name="l44"><span class="ln">44   </span></a>     *                 root.right = right; 
<a name="l45"><span class="ln">45   </span></a>     *  sols[i][j] = root; 
<a name="l46"><span class="ln">46   </span></a>     * 
<a name="l47"><span class="ln">47   </span></a>     *  We need to compute C[0][n-1] and sols[0][n-1] 
<a name="l48"><span class="ln">48   </span></a>     *  i varies from [0..n-1) 
<a name="l49"><span class="ln">49   </span></a>     *  j varies from [i+1..n) when i=0 =&gt; j=1 ; i=n-2 =&gt; j=n-1...n-1 
<a name="l50"><span class="ln">50   </span></a>     *  k varies from [i..j] 
<a name="l51"><span class="ln">51   </span></a>     * 
<a name="l52"><span class="ln">52   </span></a>     *  Boundry Cases 
<a name="l53"><span class="ln">53   </span></a>     *      when k=0, this means that first node is root, so left sub-problem is 0 
<a name="l54"><span class="ln">54   </span></a>     *      when k = n-1, this means that right most node is root, so right sub-problem is 0 
<a name="l55"><span class="ln">55   </span></a>     * 
<a name="l56"><span class="ln">56   </span></a>     *  Base Cases 
<a name="l57"><span class="ln">57   </span></a>     *  1) c[i][i] = freq[i] // for only one node cost is same as its frequency 
<a name="l58"><span class="ln">58   </span></a>     *      sols[i][i] = new Node(keys[i]); 
<a name="l59"><span class="ln">59   </span></a>     *  2) c[i][i+1] = if(1*freq[i] + 2*freq[i+1] &lt; 2*freq[i] + 1*freq[i+1]) 
<a name="l60"><span class="ln">60   </span></a>     *                      then 1*freq[i] + 2*freq[i+1] // making lower key as root 
<a name="l61"><span class="ln">61   </span></a>     *                      else 2*freq[i] + 1*freq[i+1] // making higher key as root 
<a name="l62"><span class="ln">62   </span></a>     *     sols[i][i+1] =  Node nLower = new Node(keys{i})  // making lower key as root 
<a name="l63"><span class="ln">63   </span></a>     *                     nLower.right = new Node(keys{i+1)) 
<a name="l64"><span class="ln">64   </span></a>     */</span><span class="s1"> 
<a name="l65"><span class="ln">65   </span></a> 
<a name="l66"><span class="ln">66   </span></a>    </span><span class="s0">void </span><span class="s1">computeBST() { 
<a name="l67"><span class="ln">67   </span></a> 
<a name="l68"><span class="ln">68   </span></a>        </span><span class="s0">int </span><span class="s1">n = freq.length; 
<a name="l69"><span class="ln">69   </span></a>        cost = </span><span class="s0">new int</span><span class="s1">[n][n]; 
<a name="l70"><span class="ln">70   </span></a>        sols = </span><span class="s0">new </span><span class="s1">Node[n][n]; 
<a name="l71"><span class="ln">71   </span></a> 
<a name="l72"><span class="ln">72   </span></a>        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt; n;i++) { 
<a name="l73"><span class="ln">73   </span></a>            cost[i][i] = freq[i];</span><span class="s2">// for only one node cost is same as its frequency</span><span class="s1"> 
<a name="l74"><span class="ln">74   </span></a>            sols[i][i] = </span><span class="s0">new </span><span class="s1">Node(keys[i]); </span><span class="s2">//the same node is the solution</span><span class="s1"> 
<a name="l75"><span class="ln">75   </span></a>        } 
<a name="l76"><span class="ln">76   </span></a> 
<a name="l77"><span class="ln">77   </span></a>        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt; n -</span><span class="s3">1</span><span class="s1">;i++) { 
<a name="l78"><span class="ln">78   </span></a>            </span><span class="s0">int </span><span class="s1">lowerRootCost = freq[i]+</span><span class="s3">2</span><span class="s1">*freq[i+</span><span class="s3">1</span><span class="s1">]; 
<a name="l79"><span class="ln">79   </span></a>            </span><span class="s0">int </span><span class="s1">higherRootCost = freq[i+</span><span class="s3">1</span><span class="s1">]+</span><span class="s3">2</span><span class="s1">*freq[i]; 
<a name="l80"><span class="ln">80   </span></a>            Node sol = </span><span class="s0">null</span><span class="s1">; 
<a name="l81"><span class="ln">81   </span></a>            </span><span class="s0">if</span><span class="s1">(lowerRootCost &lt;=higherRootCost) { 
<a name="l82"><span class="ln">82   </span></a>                sol = </span><span class="s0">new </span><span class="s1">Node(freq[i]); </span><span class="s2">// make the lower key as root</span><span class="s1"> 
<a name="l83"><span class="ln">83   </span></a>                sol.right = </span><span class="s0">new </span><span class="s1">Node(freq[i+</span><span class="s3">1</span><span class="s1">]); 
<a name="l84"><span class="ln">84   </span></a>                cost[i][i+</span><span class="s3">1</span><span class="s1">] = lowerRootCost; 
<a name="l85"><span class="ln">85   </span></a>                sols[i][i+</span><span class="s3">1</span><span class="s1">] = sol; 
<a name="l86"><span class="ln">86   </span></a>            } </span><span class="s0">else </span><span class="s1">{ 
<a name="l87"><span class="ln">87   </span></a>                sol = </span><span class="s0">new </span><span class="s1">Node(freq[i+</span><span class="s3">1</span><span class="s1">]); </span><span class="s2">// make the higher key as root</span><span class="s1"> 
<a name="l88"><span class="ln">88   </span></a>                sol.left = </span><span class="s0">new </span><span class="s1">Node(freq[i]); 
<a name="l89"><span class="ln">89   </span></a>                cost[i][i+</span><span class="s3">1</span><span class="s1">] = higherRootCost; 
<a name="l90"><span class="ln">90   </span></a>                sols[i][i+</span><span class="s3">1</span><span class="s1">] = sol; 
<a name="l91"><span class="ln">91   </span></a>            } 
<a name="l92"><span class="ln">92   </span></a> 
<a name="l93"><span class="ln">93   </span></a>        } 
<a name="l94"><span class="ln">94   </span></a> 
<a name="l95"><span class="ln">95   </span></a>        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt; n -</span><span class="s3">1</span><span class="s1">;i++) { 
<a name="l96"><span class="ln">96   </span></a>            </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">j=i+</span><span class="s3">1</span><span class="s1">;j&lt; n;j++) { 
<a name="l97"><span class="ln">97   </span></a>                </span><span class="s0">int </span><span class="s1">min = Integer.MAX_VALUE; 
<a name="l98"><span class="ln">98   </span></a>                </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=i;k&lt;=j;k++) { 
<a name="l99"><span class="ln">99   </span></a>                    </span><span class="s2">// if k ==0, this means we are on first key so left cost will be 0</span><span class="s1"> 
<a name="l100"><span class="ln">100  </span></a>                    </span><span class="s0">int </span><span class="s1">leftCost = k &gt; </span><span class="s3">0 </span><span class="s1">? cost[i][k - </span><span class="s3">1</span><span class="s1">] + sum(i, k - </span><span class="s3">1</span><span class="s1">): </span><span class="s3">0</span><span class="s1">; 
<a name="l101"><span class="ln">101  </span></a> 
<a name="l102"><span class="ln">102  </span></a>                    </span><span class="s2">// if k&gt;=n-1 means we are already on last key so right cost will be 0</span><span class="s1"> 
<a name="l103"><span class="ln">103  </span></a>                    </span><span class="s0">int </span><span class="s1">rightCost = k&lt; n-</span><span class="s3">1 </span><span class="s1">? cost[k + </span><span class="s3">1</span><span class="s1">][j] + sum(k + </span><span class="s3">1</span><span class="s1">, j) : </span><span class="s3">0</span><span class="s1">; 
<a name="l104"><span class="ln">104  </span></a> 
<a name="l105"><span class="ln">105  </span></a>                    </span><span class="s0">int </span><span class="s1">t = leftCost + freq[k] + rightCost; </span><span class="s2">// compute cost with this as root</span><span class="s1"> 
<a name="l106"><span class="ln">106  </span></a>                    Node r = </span><span class="s0">new </span><span class="s1">Node(keys[k]); 
<a name="l107"><span class="ln">107  </span></a> 
<a name="l108"><span class="ln">108  </span></a>                    </span><span class="s0">if</span><span class="s1">(t &lt; min) { </span><span class="s2">// if better cost found update solution</span><span class="s1"> 
<a name="l109"><span class="ln">109  </span></a>                        min = t; 
<a name="l110"><span class="ln">110  </span></a>                        sols[i][j] = r; 
<a name="l111"><span class="ln">111  </span></a>                        </span><span class="s0">if</span><span class="s1">(k ==</span><span class="s3">0</span><span class="s1">) { 
<a name="l112"><span class="ln">112  </span></a>                            r.left =</span><span class="s0">null</span><span class="s1">; 
<a name="l113"><span class="ln">113  </span></a>                            r.right = sols[k+</span><span class="s3">1</span><span class="s1">][j]; 
<a name="l114"><span class="ln">114  </span></a>                        } </span><span class="s0">else if</span><span class="s1">(k == n-</span><span class="s3">1</span><span class="s1">) { 
<a name="l115"><span class="ln">115  </span></a>                            r.right =</span><span class="s0">null</span><span class="s1">; 
<a name="l116"><span class="ln">116  </span></a>                            r.left = sols[i][k-</span><span class="s3">1</span><span class="s1">]; 
<a name="l117"><span class="ln">117  </span></a>                        } 
<a name="l118"><span class="ln">118  </span></a>                        </span><span class="s0">else </span><span class="s1">{ 
<a name="l119"><span class="ln">119  </span></a>                            r.left = sols[i][k-</span><span class="s3">1</span><span class="s1">]; 
<a name="l120"><span class="ln">120  </span></a>                            r.left = sols[k+</span><span class="s3">1</span><span class="s1">][i]; 
<a name="l121"><span class="ln">121  </span></a>                        } 
<a name="l122"><span class="ln">122  </span></a> 
<a name="l123"><span class="ln">123  </span></a>                        cost[i][j] = min; 
<a name="l124"><span class="ln">124  </span></a>                        sols[i][j] =r; 
<a name="l125"><span class="ln">125  </span></a>                    } 
<a name="l126"><span class="ln">126  </span></a>                } 
<a name="l127"><span class="ln">127  </span></a> 
<a name="l128"><span class="ln">128  </span></a>            } 
<a name="l129"><span class="ln">129  </span></a>        } 
<a name="l130"><span class="ln">130  </span></a>        System.out.println(cost[</span><span class="s3">0</span><span class="s1">][n -</span><span class="s3">1</span><span class="s1">]); 
<a name="l131"><span class="ln">131  </span></a>        System.out.println(sols[</span><span class="s3">0</span><span class="s1">][n -</span><span class="s3">1</span><span class="s1">]); 
<a name="l132"><span class="ln">132  </span></a>    } 
<a name="l133"><span class="ln">133  </span></a> 
<a name="l134"><span class="ln">134  </span></a>    </span><span class="s0">private int </span><span class="s1">sum(</span><span class="s0">int </span><span class="s1">i,</span><span class="s0">int </span><span class="s1">j){ 
<a name="l135"><span class="ln">135  </span></a>        </span><span class="s0">int </span><span class="s1">ret =</span><span class="s3">0</span><span class="s1">; 
<a name="l136"><span class="ln">136  </span></a>        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=i;k&lt;=j;k++) 
<a name="l137"><span class="ln">137  </span></a>        { 
<a name="l138"><span class="ln">138  </span></a>            ret = ret + freq[k]; 
<a name="l139"><span class="ln">139  </span></a>        } 
<a name="l140"><span class="ln">140  </span></a>        </span><span class="s0">return </span><span class="s1">ret; 
<a name="l141"><span class="ln">141  </span></a>    } 
<a name="l142"><span class="ln">142  </span></a> 
<a name="l143"><span class="ln">143  </span></a>    </span><span class="s0">public static void </span><span class="s1">main(String[] args) { 
<a name="l144"><span class="ln">144  </span></a>        OptimalBST bst = </span><span class="s0">new </span><span class="s1">OptimalBST(); 
<a name="l145"><span class="ln">145  </span></a>        </span><span class="s0">int </span><span class="s1">keys[] = {</span><span class="s3">10</span><span class="s1">, </span><span class="s3">12</span><span class="s1">, </span><span class="s3">20</span><span class="s1">}; 
<a name="l146"><span class="ln">146  </span></a>        </span><span class="s0">int </span><span class="s1">freq[] = {</span><span class="s3">34</span><span class="s1">, </span><span class="s3">8</span><span class="s1">, </span><span class="s3">50</span><span class="s1">}; 
<a name="l147"><span class="ln">147  </span></a>        bst.keys = keys; 
<a name="l148"><span class="ln">148  </span></a>        bst.freq = freq; 
<a name="l149"><span class="ln">149  </span></a>        bst.computeBST(); 
<a name="l150"><span class="ln">150  </span></a>    } 
<a name="l151"><span class="ln">151  </span></a> 
<a name="l152"><span class="ln">152  </span></a>} 
<a name="l153"><span class="ln">153  </span></a></span></pre>
</body>
</html>